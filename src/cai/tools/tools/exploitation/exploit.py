"""
Exploit tools
====================

This module implements a simple set of functions to assist with the
exploitation phase of the kill‑chain.  The functions here are meant
to provide basic wrappers around common exploitation utilities so
that they can be invoked from an AI agent with minimal prompting.

The code relies on the :func:`cai.tools.common.run_command` helper to
execute commands in the appropriate environment (local host, Docker
container, CTF sandbox, etc.).  Each function is decorated with
``@function_tool`` so that it can be automatically registered with
CAI's agent framework.  If the underlying tool is not installed on
the target system, the commands will fail and return the error
output from the shell.
"""

from cai.tools.common import run_command  # pylint: disable=import-error
from cai.sdk.agents import function_tool  # pylint: disable=import-error


@function_tool
def exploit(command: str, args: str = "", target: str = "", ctf=None) -> str:
    """Execute an arbitrary exploitation command.

    This helper allows the agent to run any exploitation command with
    optional arguments and an optional target.  It simply concatenates
    the parameters and delegates execution to :func:`run_command`.

    Args:
        command: The base command or exploit to run (e.g. ``searchsploit`` or
                 the path to an exploit script).
        args: Additional flags or arguments for the command.
        target: The optional target IP address, hostname or service
                 arguments; it will be appended to the command as‑is.
        ctf: Optional CTF sandbox context provided by CAI.

    Returns:
        The stdout/stderr produced by the underlying shell command.
    """
    full_cmd = " ".join(filter(None, [command, args, target])).strip()
    if not full_cmd:
        return "No command provided."
    return run_command(full_cmd, ctf=ctf)


@function_tool
def search_exploit(term: str, ctf=None) -> str:
    """Search public exploit databases for a given term using ``searchsploit``.

    This function wraps the ``searchsploit`` utility provided by
    Offensive Security's Exploit‑DB.  You can search by CVE identifier,
    product name, version, or other keywords.  If searchsploit is not
    installed on the host, this call will return the corresponding
    shell error message.

    Args:
        term: The keyword, CVE ID or search expression.
        ctf: Optional CTF sandbox context provided by CAI.

    Returns:
        The output returned by ``searchsploit term``.
    """
    if not term:
        return "Please provide a search term."
    return run_command(f"searchsploit {term}", ctf=ctf)


# ---------------------------------------------------------------------------
# Extended functionality
# ---------------------------------------------------------------------------


@function_tool
def pattern_create(length: int = 200, ctf=None) -> str:
    """Generate a cyclic pattern for buffer overflow analysis.

    This helper uses Metasploit's ``msf-pattern_create`` utility to create
    a unique, non‑repeating pattern of the specified length.  Such
    patterns are useful when determining the exact offset at which a
    buffer overflow overwrites control data.

    Args:
        length: Total length of the pattern to generate.  Defaults to 200.
        ctf: Optional CTF sandbox context.

    Returns:
        The generated pattern, or an error message if ``msf-pattern_create``
        is not installed.
    """
    return run_command(f"msf-pattern_create -l {length}", ctf=ctf)


@function_tool
def pattern_offset(value: str, length: int = 200, ctf=None) -> str:
    """Calculate the offset of a given value within a cyclic pattern.

    After generating a crash using a cyclic pattern, use this function
    to determine the exact offset where your value (e.g. the overwritten
    return address) appears.  It calls Metasploit's
    ``msf-pattern_offset`` utility.

    Args:
        value: The 4‑byte or 8‑byte value to locate within the pattern.
        length: The length of the original pattern (default 200).  This
            should match the length used when calling :func:`pattern_create`.
        ctf: Optional CTF sandbox context.

    Returns:
        The offset as reported by ``msf-pattern_offset``, or an error
        message if the tool is not available.
    """
    return run_command(f"msf-pattern_offset -q {value} -l {length}", ctf=ctf)


@function_tool
def run_msf_module(module: str, options: str = "", autopwn: bool = True, ctf=None) -> str:
    """Run a Metasploit module with the given options.

    This convenience wrapper starts ``msfconsole`` in quiet mode and
    executes a specified module.  It accepts a string of additional
    commands to set module options (e.g. ``set RHOSTS 10.0.0.1; set
    RPORT 80``).  If ``autopwn`` is True, the function will automatically
    call ``exploit -z`` to launch the module in the background and return
    control immediately.  You can disable autopwn to simply prepare
    the environment and leave exploitation to the user.

    Note: ``msfconsole`` can be slow to start and may not be installed
    in all environments.  Use responsibly and only on authorised
    systems.

    Args:
        module: Name of the Metasploit module to use (e.g.
            ``exploit/multi/http/apache_mod_cgi_bash_env_exec``).
        options: Semicolon‑separated module commands to set options.
        autopwn: Whether to automatically run the module after setting
            options.  Defaults to True.
        ctf: Optional CTF sandbox context.

    Returns:
        Output produced by ``msfconsole``.  If the tool is not
        installed, the command will fail with an error message.
    """
    # Prepare the sequence of commands to run inside msfconsole
    commands = [f"use {module}"]
    if options:
        # Normalize multiple commands separated by semicolons
        for cmd in options.split(';'):
            cmd = cmd.strip()
            if cmd:
                commands.append(cmd)
    if autopwn:
        commands.append("exploit -z")  # Launch exploit in the background
    commands.append("exit")
    msf_cmd = " ; ".join(commands)
    return run_command(f"msfconsole -q -x '{msf_cmd}'", ctf=ctf)